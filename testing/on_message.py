
# Generated by CodiumAI

import unittest
from app import on_message


class TestOnMessage(unittest.TestCase):

    #  The function receives a message string and processes it successfully.
    @unittest.mock.patch('chainlit.user_session.get')
    @unittest.mock.patch('chainlit.Message')
    @unittest.mock.patch('asyncio.sleep')
    async def test_process_message_successfully(self, mock_sleep, mock_Message, mock_get):
        mock_get.side_effect = lambda key: {'llm_chain': lambda message, stream, display, uuid: [chunk1, chunk2, chunk3]}
        mock_Message.side_effect = lambda content, language=None: {'content': content, 'language': language}
        mock_Message.return_value.stream_token.side_effect = lambda token: None
        mock_Message.return_value.send.side_effect = lambda: None

        await on_message("test message")

        mock_get.assert_called_with("llm_chain")
        mock_Message.assert_called_with(content="")
        mock_Message.return_value.stream_token.assert_called_with(token=chunk['message'])
        mock_Message.return_value.send.assert_called()
        mock_sleep.assert_called_with(DELAY)

    #  The function handles messages with no content.
    @unittest.mock.patch('chainlit.user_session.get')
    @unittest.mock.patch('chainlit.Message')
    @unittest.mock.patch('asyncio.sleep')
    async def test_handle_message_with_no_content(self, mock_sleep, mock_Message, mock_get):
        mock_get.side_effect = lambda key: {'llm_chain': lambda message, stream, display, uuid: [chunk1, chunk2, chunk3]}
        mock_Message.side_effect = lambda content, language=None: {'content': content, 'language': language}
        mock_Message.return_value.stream_token.side_effect = lambda token: None
        mock_Message.return_value.send.side_effect = lambda: None

        await on_message("")

        mock_get.assert_called_with("llm_chain")
        mock_Message.assert_called_with(content="")
        mock_Message.return_value.stream_token.assert_called_with(token=chunk['message'])
        mock_Message.return_value.send.assert_called()
        mock_sleep.assert_called_with(DELAY)

    #  The function handles messages with only code content.
    @unittest.mock.patch('chainlit.user_session.get')
    @unittest.mock.patch('chainlit.Message')
    @unittest.mock.patch('asyncio.sleep')
    async def test_handle_message_with_only_code_content(self, mock_sleep, mock_Message, mock_get):
        mock_get.side_effect = lambda key: {'llm_chain': lambda message, stream, display, uuid: [chunk1, chunk2, chunk3]}
        mock_Message.side_effect = lambda content, language=None: {'content': content, 'language': language}
        mock_Message.return_value.stream_token.side_effect = lambda token: None
        mock_Message.return_value.send.side_effect = lambda: None

        await on_message("test code")

        mock_get.assert_called_with("llm_chain")
        mock_Message.assert_called_with(content="")
        mock_Message.return_value.stream_token.assert_called_with(token=chunk['code'])
        mock_Message.return_value.send.assert_called()
        mock_sleep.assert_called_with(DELAY)

    #  The function raises an error if llm_chain is not found in user_session.
    @unittest.mock.patch('chainlit.user_session.get')
    async def test_raise_error_if_llm_chain_not_found(self, mock_get):
        mock_get.side_effect = lambda key: None

        with self.assertRaises(Exception):
            await on_message("test message")

        mock_get.assert_called_with("llm_chain")

    #  The function raises an error if unique_id is not found in user_session.
    @unittest.mock.patch('chainlit.user_session.get')
    async def test_raise_error_if_unique_id_not_found(self, mock_get):
        mock_get.side_effect = lambda key: {'llm_chain': lambda message, stream, display, uuid: [chunk1, chunk2, chunk3]}

        with self.assertRaises(Exception):
            await on_message("test message")

        mock_get.assert_called_with("unique_id")

    #  The function raises an error if there is an issue with the llm_chain processing.
    @unittest.mock.patch('chainlit.user_session.get')
    async def test_raise_error_if_llm_chain_processing_issue(self, mock_get):
        mock_get.side_effect = lambda key: {'llm_chain': lambda message, stream, display, uuid: [chunk1, chunk2, chunk3]}

        with self.assertRaises(Exception):
            await on_message("test message")

        mock_get.assert_called_with("llm_chain")
